{"ast":null,"code":"\"use strict\";\n\nimport { BaseNavigationContainer, getActionFromState, getPathFromState, getStateFromPath, ThemeProvider, validatePathConfig } from '@react-navigation/core';\nimport * as React from 'react';\nimport { I18nManager } from 'react-native';\nimport useLatestCallback from 'use-latest-callback';\nimport { LinkingContext } from \"./LinkingContext.js\";\nimport { LocaleDirContext } from \"./LocaleDirContext.js\";\nimport { DefaultTheme } from \"./theming/DefaultTheme.js\";\nimport { UnhandledLinkingContext } from \"./UnhandledLinkingContext.js\";\nimport { useBackButton } from './useBackButton.js';\nimport { useDocumentTitle } from './useDocumentTitle.js';\nimport { useLinking } from './useLinking.js';\nimport { useThenable } from \"./useThenable.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nglobalThis.REACT_NAVIGATION_DEVTOOLS = new WeakMap();\n/**\n * Container component which holds the navigation state designed for React Native apps.\n * This should be rendered at the root wrapping the whole app.\n *\n * @param props.initialState Initial state object for the navigation tree. When deep link handling is enabled, this will override deep links when specified. Make sure that you don't specify an `initialState` when there's a deep link (`Linking.getInitialURL()`).\n * @param props.onReady Callback which is called after the navigation tree mounts.\n * @param props.onStateChange Callback which is called with the latest navigation state when it changes.\n * @param props.onUnhandledAction Callback which is called when an action is not handled.\n * @param props.direction Text direction of the components. Defaults to `'ltr'`.\n * @param props.theme Theme object for the UI elements.\n * @param props.linking Options for deep linking. Deep link handling is enabled when this prop is provided, unless `linking.enabled` is `false`.\n * @param props.fallback Fallback component to render until we have finished getting initial state when linking is enabled. Defaults to `null`.\n * @param props.documentTitle Options to configure the document title on Web. Updating document title is handled by default unless `documentTitle.enabled` is `false`.\n * @param props.children Child elements to render the content.\n * @param props.ref Ref object which refers to the navigation object containing helper methods.\n */\nfunction NavigationContainerInner(_ref, ref) {\n  let {\n    direction = I18nManager.getConstants().isRTL ? 'rtl' : 'ltr',\n    theme = DefaultTheme,\n    linking,\n    fallback = null,\n    documentTitle,\n    onReady,\n    onStateChange,\n    ...rest\n  } = _ref;\n  const isLinkingEnabled = linking ? linking.enabled !== false : false;\n  if (linking?.config) {\n    validatePathConfig(linking.config);\n  }\n  const refContainer = React.useRef(null);\n  useBackButton(refContainer);\n  useDocumentTitle(refContainer, documentTitle);\n  const [lastUnhandledLink, setLastUnhandledLink] = React.useState();\n  const {\n    getInitialState\n  } = useLinking(refContainer, {\n    enabled: isLinkingEnabled,\n    prefixes: [],\n    ...linking\n  }, setLastUnhandledLink);\n  const linkingContext = React.useMemo(() => ({\n    options: linking\n  }), [linking]);\n  const unhandledLinkingContext = React.useMemo(() => ({\n    lastUnhandledLink,\n    setLastUnhandledLink\n  }), [lastUnhandledLink, setLastUnhandledLink]);\n  const onReadyForLinkingHandling = useLatestCallback(() => {\n    // If the screen path matches lastUnhandledLink, we do not track it\n    const path = refContainer.current?.getCurrentRoute()?.path;\n    setLastUnhandledLink(previousLastUnhandledLink => {\n      if (previousLastUnhandledLink === path) {\n        return undefined;\n      }\n      return previousLastUnhandledLink;\n    });\n    onReady?.();\n  });\n  const onStateChangeForLinkingHandling = useLatestCallback(state => {\n    // If the screen path matches lastUnhandledLink, we do not track it\n    const path = refContainer.current?.getCurrentRoute()?.path;\n    setLastUnhandledLink(previousLastUnhandledLink => {\n      if (previousLastUnhandledLink === path) {\n        return undefined;\n      }\n      return previousLastUnhandledLink;\n    });\n    onStateChange?.(state);\n  });\n  // Add additional linking related info to the ref\n  // This will be used by the devtools\n  React.useEffect(() => {\n    if (refContainer.current) {\n      REACT_NAVIGATION_DEVTOOLS.set(refContainer.current, {\n        get linking() {\n          return {\n            ...linking,\n            enabled: isLinkingEnabled,\n            prefixes: linking?.prefixes ?? [],\n            getStateFromPath: linking?.getStateFromPath ?? getStateFromPath,\n            getPathFromState: linking?.getPathFromState ?? getPathFromState,\n            getActionFromState: linking?.getActionFromState ?? getActionFromState\n          };\n        }\n      });\n    }\n  });\n  const [isResolved, initialState] = useThenable(getInitialState);\n  React.useImperativeHandle(ref, () => refContainer.current);\n  const isLinkingReady = rest.initialState != null || !isLinkingEnabled || isResolved;\n  if (!isLinkingReady) {\n    // This is temporary until we have Suspense for data-fetching\n    // Then the fallback will be handled by a parent `Suspense` component\n    return /*#__PURE__*/_jsx(ThemeProvider, {\n      value: theme,\n      children: fallback\n    });\n  }\n  return /*#__PURE__*/_jsx(LocaleDirContext.Provider, {\n    value: direction,\n    children: /*#__PURE__*/_jsx(UnhandledLinkingContext.Provider, {\n      value: unhandledLinkingContext,\n      children: /*#__PURE__*/_jsx(LinkingContext.Provider, {\n        value: linkingContext,\n        children: /*#__PURE__*/_jsx(BaseNavigationContainer, {\n          ...rest,\n          theme: theme,\n          onReady: onReadyForLinkingHandling,\n          onStateChange: onStateChangeForLinkingHandling,\n          initialState: rest.initialState == null ? initialState : rest.initialState,\n          ref: refContainer\n        })\n      })\n    })\n  });\n}\nexport const NavigationContainer = /*#__PURE__*/React.forwardRef(NavigationContainerInner);","map":{"version":3,"names":["BaseNavigationContainer","getActionFromState","getPathFromState","getStateFromPath","ThemeProvider","validatePathConfig","React","I18nManager","useLatestCallback","LinkingContext","LocaleDirContext","DefaultTheme","UnhandledLinkingContext","useBackButton","useDocumentTitle","useLinking","useThenable","jsx","_jsx","globalThis","REACT_NAVIGATION_DEVTOOLS","WeakMap","NavigationContainerInner","_ref","ref","direction","getConstants","isRTL","theme","linking","fallback","documentTitle","onReady","onStateChange","rest","isLinkingEnabled","enabled","config","refContainer","useRef","lastUnhandledLink","setLastUnhandledLink","useState","getInitialState","prefixes","linkingContext","useMemo","options","unhandledLinkingContext","onReadyForLinkingHandling","path","current","getCurrentRoute","previousLastUnhandledLink","undefined","onStateChangeForLinkingHandling","state","useEffect","set","isResolved","initialState","useImperativeHandle","isLinkingReady","value","children","Provider","NavigationContainer","forwardRef"],"sources":["C:\\Users\\rohan_gs\\bank-ez\\frontend\\node_modules\\@react-navigation\\native\\src\\NavigationContainer.tsx"],"sourcesContent":["import {\n  BaseNavigationContainer,\n  getActionFromState,\n  getPathFromState,\n  getStateFromPath,\n  type NavigationContainerProps,\n  type NavigationContainerRef,\n  type NavigationState,\n  type ParamListBase,\n  ThemeProvider,\n  validatePathConfig,\n} from '@react-navigation/core';\nimport * as React from 'react';\nimport { I18nManager } from 'react-native';\nimport useLatestCallback from 'use-latest-callback';\n\nimport { LinkingContext } from './LinkingContext';\nimport { LocaleDirContext } from './LocaleDirContext';\nimport { DefaultTheme } from './theming/DefaultTheme';\nimport type {\n  DocumentTitleOptions,\n  LinkingOptions,\n  LocaleDirection,\n} from './types';\nimport { UnhandledLinkingContext } from './UnhandledLinkingContext';\nimport { useBackButton } from './useBackButton';\nimport { useDocumentTitle } from './useDocumentTitle';\nimport { useLinking } from './useLinking';\nimport { useThenable } from './useThenable';\n\ndeclare global {\n  // eslint-disable-next-line no-var\n  var REACT_NAVIGATION_DEVTOOLS: WeakMap<\n    NavigationContainerRef<any>,\n    { readonly linking: LinkingOptions<any> }\n  >;\n}\n\nglobalThis.REACT_NAVIGATION_DEVTOOLS = new WeakMap();\n\ntype Props<ParamList extends {}> = NavigationContainerProps & {\n  direction?: LocaleDirection;\n  linking?: LinkingOptions<ParamList>;\n  fallback?: React.ReactNode;\n  documentTitle?: DocumentTitleOptions;\n};\n\n/**\n * Container component which holds the navigation state designed for React Native apps.\n * This should be rendered at the root wrapping the whole app.\n *\n * @param props.initialState Initial state object for the navigation tree. When deep link handling is enabled, this will override deep links when specified. Make sure that you don't specify an `initialState` when there's a deep link (`Linking.getInitialURL()`).\n * @param props.onReady Callback which is called after the navigation tree mounts.\n * @param props.onStateChange Callback which is called with the latest navigation state when it changes.\n * @param props.onUnhandledAction Callback which is called when an action is not handled.\n * @param props.direction Text direction of the components. Defaults to `'ltr'`.\n * @param props.theme Theme object for the UI elements.\n * @param props.linking Options for deep linking. Deep link handling is enabled when this prop is provided, unless `linking.enabled` is `false`.\n * @param props.fallback Fallback component to render until we have finished getting initial state when linking is enabled. Defaults to `null`.\n * @param props.documentTitle Options to configure the document title on Web. Updating document title is handled by default unless `documentTitle.enabled` is `false`.\n * @param props.children Child elements to render the content.\n * @param props.ref Ref object which refers to the navigation object containing helper methods.\n */\nfunction NavigationContainerInner(\n  {\n    direction = I18nManager.getConstants().isRTL ? 'rtl' : 'ltr',\n    theme = DefaultTheme,\n    linking,\n    fallback = null,\n    documentTitle,\n    onReady,\n    onStateChange,\n    ...rest\n  }: Props<ParamListBase>,\n  ref?: React.Ref<NavigationContainerRef<ParamListBase> | null>\n) {\n  const isLinkingEnabled = linking ? linking.enabled !== false : false;\n\n  if (linking?.config) {\n    validatePathConfig(linking.config);\n  }\n\n  const refContainer =\n    React.useRef<NavigationContainerRef<ParamListBase>>(null);\n\n  useBackButton(refContainer);\n  useDocumentTitle(refContainer, documentTitle);\n\n  const [lastUnhandledLink, setLastUnhandledLink] = React.useState<\n    string | undefined\n  >();\n\n  const { getInitialState } = useLinking(\n    refContainer,\n    {\n      enabled: isLinkingEnabled,\n      prefixes: [],\n      ...linking,\n    },\n    setLastUnhandledLink\n  );\n\n  const linkingContext = React.useMemo(() => ({ options: linking }), [linking]);\n\n  const unhandledLinkingContext = React.useMemo(\n    () => ({ lastUnhandledLink, setLastUnhandledLink }),\n    [lastUnhandledLink, setLastUnhandledLink]\n  );\n\n  const onReadyForLinkingHandling = useLatestCallback(() => {\n    // If the screen path matches lastUnhandledLink, we do not track it\n    const path = refContainer.current?.getCurrentRoute()?.path;\n    setLastUnhandledLink((previousLastUnhandledLink) => {\n      if (previousLastUnhandledLink === path) {\n        return undefined;\n      }\n      return previousLastUnhandledLink;\n    });\n    onReady?.();\n  });\n\n  const onStateChangeForLinkingHandling = useLatestCallback(\n    (state: Readonly<NavigationState> | undefined) => {\n      // If the screen path matches lastUnhandledLink, we do not track it\n      const path = refContainer.current?.getCurrentRoute()?.path;\n      setLastUnhandledLink((previousLastUnhandledLink) => {\n        if (previousLastUnhandledLink === path) {\n          return undefined;\n        }\n        return previousLastUnhandledLink;\n      });\n      onStateChange?.(state);\n    }\n  );\n  // Add additional linking related info to the ref\n  // This will be used by the devtools\n  React.useEffect(() => {\n    if (refContainer.current) {\n      REACT_NAVIGATION_DEVTOOLS.set(refContainer.current, {\n        get linking() {\n          return {\n            ...linking,\n            enabled: isLinkingEnabled,\n            prefixes: linking?.prefixes ?? [],\n            getStateFromPath: linking?.getStateFromPath ?? getStateFromPath,\n            getPathFromState: linking?.getPathFromState ?? getPathFromState,\n            getActionFromState:\n              linking?.getActionFromState ?? getActionFromState,\n          };\n        },\n      });\n    }\n  });\n\n  const [isResolved, initialState] = useThenable(getInitialState);\n\n  React.useImperativeHandle(ref, () => refContainer.current);\n\n  const isLinkingReady =\n    rest.initialState != null || !isLinkingEnabled || isResolved;\n\n  if (!isLinkingReady) {\n    // This is temporary until we have Suspense for data-fetching\n    // Then the fallback will be handled by a parent `Suspense` component\n    return <ThemeProvider value={theme}>{fallback}</ThemeProvider>;\n  }\n\n  return (\n    <LocaleDirContext.Provider value={direction}>\n      <UnhandledLinkingContext.Provider value={unhandledLinkingContext}>\n        <LinkingContext.Provider value={linkingContext}>\n          <BaseNavigationContainer\n            {...rest}\n            theme={theme}\n            onReady={onReadyForLinkingHandling}\n            onStateChange={onStateChangeForLinkingHandling}\n            initialState={\n              rest.initialState == null ? initialState : rest.initialState\n            }\n            ref={refContainer}\n          />\n        </LinkingContext.Provider>\n      </UnhandledLinkingContext.Provider>\n    </LocaleDirContext.Provider>\n  );\n}\n\nexport const NavigationContainer = React.forwardRef(\n  NavigationContainerInner\n) as <RootParamList extends {} = ReactNavigation.RootParamList>(\n  props: Props<RootParamList> & {\n    ref?: React.Ref<NavigationContainerRef<RootParamList>>;\n  }\n) => React.ReactElement;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}