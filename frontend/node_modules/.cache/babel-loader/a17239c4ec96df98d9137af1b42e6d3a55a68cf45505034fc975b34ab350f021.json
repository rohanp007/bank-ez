{"ast":null,"code":"\"use strict\";\n\nimport * as React from 'react';\nimport { isValidElementType } from 'react-is';\nimport { useRoute } from \"./useRoute.js\";\n\n/**\n * Flatten a type to remove all type alias names, unions etc.\n * This will show a plain object when hovering over the type.\n */\n\n/**\n * keyof T doesn't work for union types. We can use distributive conditional types instead.\n * https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\n */\n\n/**\n * We get a union type when using keyof, but we want an intersection instead.\n * https://stackoverflow.com/a/50375286/1665026\n */\n\n/**\n * Props for a screen component which is rendered by a static navigator.\n * Takes the route params as a generic argument.\n */\n\n/**\n * Infer the param list from the static navigation config.\n */\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { createElement as _createElement } from \"react\";\nconst MemoizedScreen = /*#__PURE__*/React.memo(({\n  component\n}) => {\n  const route = useRoute();\n  const children = /*#__PURE__*/React.createElement(component, {\n    route\n  });\n  return children;\n});\nMemoizedScreen.displayName = 'Memo(Screen)';\nconst getItemsFromScreens = (Screen, screens) => {\n  return Object.entries(screens).map(([name, item]) => {\n    let component;\n    let props = {};\n    let useIf;\n    let isNavigator = false;\n    if ('screen' in item) {\n      const {\n        screen,\n        if: _if,\n        ...rest\n      } = item;\n      useIf = _if;\n      props = rest;\n      if (isValidElementType(screen)) {\n        component = screen;\n      } else if ('config' in screen) {\n        isNavigator = true;\n        component = createComponentForStaticNavigation(screen, `${name}Navigator`);\n      }\n    } else if (isValidElementType(item)) {\n      component = item;\n    } else if ('config' in item) {\n      isNavigator = true;\n      component = createComponentForStaticNavigation(item, `${name}Navigator`);\n    }\n    if (component == null) {\n      throw new Error(`Couldn't find a 'screen' property for the screen '${name}'. This can happen if you passed 'undefined'. You likely forgot to export your component from the file it's defined in, or mixed up default import and named import when importing.`);\n    }\n    const element = isNavigator ? (/*#__PURE__*/React.createElement(component, {})) : /*#__PURE__*/_jsx(MemoizedScreen, {\n      component: component\n    });\n    return () => {\n      const shouldRender = useIf == null || useIf();\n      if (!shouldRender) {\n        return null;\n      }\n      return /*#__PURE__*/_jsx(Screen, {\n        name: name,\n        ...props,\n        children: () => element\n      }, name);\n    };\n  });\n};\n\n/**\n * Create a component that renders a navigator based on the static configuration.\n *\n * @param tree Static navigation config.\n * @param displayName Name of the component to be displayed in React DevTools.\n * @returns A component which renders the navigator.\n */\nexport function createComponentForStaticNavigation(tree, displayName) {\n  const {\n    Navigator,\n    Group,\n    Screen,\n    config\n  } = tree;\n  const {\n    screens,\n    groups,\n    ...rest\n  } = config;\n  if (screens == null && groups == null) {\n    throw new Error(\"Couldn't find a 'screens' or 'groups' property. Make sure to define your screens under a 'screens' property in the configuration.\");\n  }\n  const items = [];\n\n  // Loop through the config to find screens and groups\n  // So we add the screens and groups in the same order as they are defined\n  for (const key in config) {\n    if (key === 'screens' && screens) {\n      items.push(...getItemsFromScreens(Screen, screens));\n    }\n    if (key === 'groups' && groups) {\n      items.push(...Object.entries(groups).map(([key, {\n        if: useIf,\n        ...group\n      }]) => {\n        const groupItems = getItemsFromScreens(Screen, group.screens);\n        return () => {\n          // Call unconditionally since screen configs may contain `useIf` hooks\n          const children = groupItems.map(item => item());\n          const shouldRender = useIf == null || useIf();\n          if (!shouldRender) {\n            return null;\n          }\n          return /*#__PURE__*/_createElement(Group, {\n            navigationKey: key,\n            ...group,\n            key: key\n          }, children);\n        };\n      }));\n    }\n  }\n  const NavigatorComponent = () => {\n    const children = items.map(item => item());\n    return /*#__PURE__*/_jsx(Navigator, {\n      ...rest,\n      children: children\n    });\n  };\n  NavigatorComponent.displayName = displayName;\n  return NavigatorComponent;\n}\n/**\n * Create a path config object from a static navigation config for deep linking.\n *\n * @param tree Static navigation config.\n * @param options Additional options from `linking.config`.\n * @param auto Whether to automatically generate paths for leaf screens.\n * @returns Path config object to use in linking config.\n *\n * @example\n * ```js\n * const config = {\n *   screens: {\n *     Home: {\n *       screens: createPathConfigForStaticNavigation(HomeTabs),\n *     },\n *   },\n * };\n * ```\n */\nexport function createPathConfigForStaticNavigation(tree, options, auto) {\n  let initialScreenConfig;\n  const createPathConfigForTree = (t, o, skipInitialDetection) => {\n    const createPathConfigForScreens = (screens, initialRouteName) => {\n      return Object.fromEntries(Object.entries(screens)\n      // Re-order to move the initial route to the front\n      // This way we can detect the initial route correctly\n      .sort(([a], [b]) => {\n        if (a === initialRouteName) {\n          return -1;\n        }\n        if (b === initialRouteName) {\n          return 1;\n        }\n        return 0;\n      }).map(([key, item]) => {\n        const screenConfig = {};\n        if ('linking' in item) {\n          if (typeof item.linking === 'string') {\n            screenConfig.path = item.linking;\n          } else {\n            Object.assign(screenConfig, item.linking);\n          }\n        }\n        let screens;\n        if ('config' in item) {\n          screens = createPathConfigForTree(item, undefined, skipInitialDetection || screenConfig.path != null);\n        } else if ('screen' in item && 'config' in item.screen && (item.screen.config.screens || item.screen.config.groups)) {\n          screens = createPathConfigForTree(item.screen, undefined, skipInitialDetection || screenConfig.path != null);\n        }\n        if (screens) {\n          screenConfig.screens = screens;\n        }\n        if (auto && !screenConfig.screens && !('linking' in item)) {\n          if (screenConfig.path) {\n            if (!skipInitialDetection) {\n              // Normalize the path to remove leading and trailing slashes\n              const path = screenConfig.path?.split('/').filter(Boolean).join('/');\n\n              // We encounter a leaf screen with empty path,\n              // Clear the initial screen config as it's not needed anymore\n              if (!skipInitialDetection && path === '') {\n                initialScreenConfig = undefined;\n              }\n            }\n          } else {\n            if (!skipInitialDetection && initialScreenConfig == null) {\n              initialScreenConfig = screenConfig;\n            }\n            screenConfig.path = key.replace(/([A-Z]+)/g, '-$1').replace(/^-/, '').toLowerCase();\n          }\n        }\n        return [key, screenConfig];\n      }).filter(([, screen]) => Object.keys(screen).length > 0));\n    };\n    const screens = {};\n\n    // Loop through the config to find screens and groups\n    // So we add the screens and groups in the same order as they are defined\n    for (const key in t.config) {\n      if (key === 'screens' && t.config.screens) {\n        Object.assign(screens, createPathConfigForScreens(t.config.screens, o?.initialRouteName ?? t.config.initialRouteName));\n      }\n      if (key === 'groups' && t.config.groups) {\n        Object.entries(t.config.groups).forEach(([, group]) => {\n          Object.assign(screens, createPathConfigForScreens(group.screens, o?.initialRouteName ?? t.config.initialRouteName));\n        });\n      }\n    }\n    if (Object.keys(screens).length === 0) {\n      return undefined;\n    }\n    return screens;\n  };\n  const screens = createPathConfigForTree(tree, options, false);\n  if (auto && initialScreenConfig) {\n    initialScreenConfig.path = '';\n  }\n  return screens;\n}","map":{"version":3,"names":["React","isValidElementType","useRoute","jsx","_jsx","createElement","_createElement","MemoizedScreen","memo","component","route","children","displayName","getItemsFromScreens","Screen","screens","Object","entries","map","name","item","props","useIf","isNavigator","screen","if","_if","rest","createComponentForStaticNavigation","Error","element","shouldRender","tree","Navigator","Group","config","groups","items","key","push","group","groupItems","navigationKey","NavigatorComponent","createPathConfigForStaticNavigation","options","auto","initialScreenConfig","createPathConfigForTree","t","o","skipInitialDetection","createPathConfigForScreens","initialRouteName","fromEntries","sort","a","b","screenConfig","linking","path","assign","undefined","split","filter","Boolean","join","replace","toLowerCase","keys","length","forEach"],"sources":["C:\\Users\\rohan_gs\\bank-ez\\frontend\\node_modules\\@react-navigation\\core\\src\\StaticNavigation.tsx"],"sourcesContent":["import type { NavigationState, ParamListBase } from '@react-navigation/routers';\nimport * as React from 'react';\nimport { isValidElementType } from 'react-is';\n\nimport type {\n  DefaultNavigatorOptions,\n  EventMapBase,\n  NavigationListBase,\n  NavigatorScreenParams,\n  NavigatorTypeBagBase,\n  PathConfig,\n  RouteConfigComponent,\n  RouteConfigProps,\n  RouteGroupConfig,\n} from './types';\nimport { useRoute } from './useRoute';\n\n/**\n * Flatten a type to remove all type alias names, unions etc.\n * This will show a plain object when hovering over the type.\n */\ntype FlatType<T> = { [K in keyof T]: T[K] } & {};\n\n/**\n * keyof T doesn't work for union types. We can use distributive conditional types instead.\n * https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\n */\ntype KeysOf<T> = T extends {} ? keyof T : never;\n\n/**\n * We get a union type when using keyof, but we want an intersection instead.\n * https://stackoverflow.com/a/50375286/1665026\n */\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I\n) => void\n  ? I\n  : never;\n\ntype UnknownToUndefined<T> = unknown extends T ? undefined : T;\n\ntype ParamsForScreenComponent<T> = T extends {\n  screen: React.ComponentType<{ route: { params: infer P } }>;\n}\n  ? P\n  : T extends React.ComponentType<{ route: { params: infer P } }>\n    ? P\n    : undefined;\n\ntype ParamsForScreen<T> = T extends { screen: StaticNavigation<any, any, any> }\n  ? NavigatorScreenParams<StaticParamList<T['screen']>> | undefined\n  : T extends StaticNavigation<any, any, any>\n    ? NavigatorScreenParams<StaticParamList<T>> | undefined\n    : UnknownToUndefined<ParamsForScreenComponent<T>>;\n\ntype ParamListForScreens<Screens> = {\n  [Key in KeysOf<Screens>]: ParamsForScreen<Screens[Key]>;\n};\n\ntype ParamListForGroups<\n  Groups extends\n    | Readonly<{\n        [key: string]: {\n          screens: StaticConfigScreens<\n            ParamListBase,\n            NavigationState,\n            {},\n            EventMapBase,\n            any\n          >;\n        };\n      }>\n    | undefined,\n> = Groups extends {\n  [key: string]: {\n    screens: StaticConfigScreens<\n      ParamListBase,\n      NavigationState,\n      {},\n      EventMapBase,\n      any\n    >;\n  };\n}\n  ? ParamListForScreens<UnionToIntersection<Groups[keyof Groups]['screens']>>\n  : {};\n\ntype StaticRouteConfig<\n  ParamList extends ParamListBase,\n  RouteName extends keyof ParamList,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  Navigation,\n> = RouteConfigProps<\n  ParamList,\n  string,\n  State,\n  ScreenOptions,\n  EventMap,\n  Navigation\n> &\n  RouteConfigComponent<ParamList, RouteName>;\n\ntype StaticConfigScreens<\n  ParamList extends ParamListBase,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  NavigationList extends NavigationListBase<ParamList>,\n> = {\n  [RouteName in keyof ParamList]:\n    | React.ComponentType<any>\n    | StaticNavigation<any, any, any>\n    | (Omit<\n        StaticRouteConfig<\n          ParamList,\n          RouteName,\n          State,\n          ScreenOptions,\n          EventMap,\n          NavigationList[RouteName]\n        >,\n        'name' | 'component' | 'getComponent' | 'children'\n      > & {\n        /**\n         * Callback to determine whether the screen should be rendered or not.\n         * This can be useful for conditional rendering of screens,\n         * e.g. - if you want to render a different screen for logged in users.\n         *\n         * You can use a custom hook to use custom logic to determine the return value.\n         *\n         * @example\n         * ```js\n         * if: useIsLoggedIn\n         * ```\n         */\n        if?: () => boolean;\n        /**\n         * Linking config for the screen.\n         * This can be a string to specify the path, or an object with more options.\n         *\n         * @example\n         * ```js\n         * linking: {\n         *   path: 'profile/:id',\n         *   exact: true,\n         * },\n         * ```\n         */\n        linking?: PathConfig<ParamList> | string;\n        /**\n         * Static navigation config or Component to render for the screen.\n         */\n        screen: StaticNavigation<any, any, any> | React.ComponentType<any>;\n      });\n};\n\ntype GroupConfig<\n  ParamList extends ParamListBase,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  NavigationList extends NavigationListBase<ParamList>,\n> = Omit<\n  RouteGroupConfig<ParamList, ScreenOptions, NavigationList[keyof ParamList]>,\n  'screens' | 'children'\n> & {\n  /**\n   * Callback to determine whether the screens in the group should be rendered or not.\n   * This can be useful for conditional rendering of group of screens.\n   */\n  if?: () => boolean;\n  /**\n   * Static navigation config or Component to render for the screen.\n   */\n  screens: StaticConfigScreens<\n    ParamList,\n    State,\n    ScreenOptions,\n    EventMap,\n    NavigationList\n  >;\n};\n\nexport type StaticConfig<Bag extends NavigatorTypeBagBase> =\n  StaticConfigInternal<\n    Bag['ParamList'],\n    Bag['NavigatorID'],\n    Bag['State'],\n    Bag['ScreenOptions'],\n    Bag['EventMap'],\n    Bag['NavigationList'],\n    Bag['Navigator']\n  >;\n\ntype StaticConfigInternal<\n  ParamList extends ParamListBase,\n  NavigatorID extends string | undefined,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  NavigationList extends NavigationListBase<ParamList>,\n  Navigator extends React.ComponentType<any>,\n> = Omit<\n  Omit<\n    React.ComponentProps<Navigator>,\n    keyof DefaultNavigatorOptions<\n      ParamListBase,\n      string | undefined,\n      NavigationState,\n      {},\n      EventMapBase,\n      NavigationList[keyof ParamList]\n    >\n  > &\n    DefaultNavigatorOptions<\n      ParamList,\n      NavigatorID,\n      State,\n      ScreenOptions,\n      EventMap,\n      NavigationList[keyof ParamList]\n    >,\n  'screens' | 'children'\n> &\n  (\n    | {\n        /**\n         * Screens to render in the navigator and their configuration.\n         */\n        screens: StaticConfigScreens<\n          ParamList,\n          State,\n          ScreenOptions,\n          EventMap,\n          NavigationList\n        >;\n        /**\n         * Groups of screens to render in the navigator and their configuration.\n         */\n        groups?: {\n          [key: string]: GroupConfig<\n            ParamList,\n            State,\n            ScreenOptions,\n            EventMap,\n            NavigationList\n          >;\n        };\n      }\n    | {\n        /**\n         * Screens to render in the navigator and their configuration.\n         */\n        screens?: StaticConfigScreens<\n          ParamList,\n          State,\n          ScreenOptions,\n          EventMap,\n          NavigationList\n        >;\n        /**\n         * Groups of screens to render in the navigator and their configuration.\n         */\n        groups: {\n          [key: string]: GroupConfig<\n            ParamList,\n            State,\n            ScreenOptions,\n            EventMap,\n            NavigationList\n          >;\n        };\n      }\n  );\n\n/**\n * Props for a screen component which is rendered by a static navigator.\n * Takes the route params as a generic argument.\n */\nexport type StaticScreenProps<T extends Record<string, unknown> | undefined> = {\n  route: {\n    params: T;\n  };\n};\n\n/**\n * Infer the param list from the static navigation config.\n */\nexport type StaticParamList<\n  T extends {\n    readonly config: {\n      readonly screens?: Record<string, any>;\n      readonly groups?: {\n        [key: string]: {\n          screens: Record<string, any>;\n        };\n      };\n    };\n  },\n> = FlatType<\n  ParamListForScreens<T['config']['screens']> &\n    ParamListForGroups<T['config']['groups']>\n>;\n\nexport type StaticNavigation<NavigatorProps, GroupProps, ScreenProps> = {\n  Navigator: React.ComponentType<NavigatorProps>;\n  Group: React.ComponentType<GroupProps>;\n  Screen: React.ComponentType<ScreenProps>;\n  config: StaticConfig<NavigatorTypeBagBase>;\n};\n\nconst MemoizedScreen = React.memo(\n  <T extends React.ComponentType<any>>({ component }: { component: T }) => {\n    const route = useRoute();\n    const children = React.createElement(component, { route });\n\n    return children;\n  }\n);\n\nMemoizedScreen.displayName = 'Memo(Screen)';\n\nconst getItemsFromScreens = (\n  Screen: React.ComponentType<any>,\n  screens: StaticConfigScreens<any, any, any, any, any>\n) => {\n  return Object.entries(screens).map(([name, item]) => {\n    let component: React.ComponentType<any> | undefined;\n    let props: {} = {};\n    let useIf: (() => boolean) | undefined;\n\n    let isNavigator = false;\n\n    if ('screen' in item) {\n      const { screen, if: _if, ...rest } = item;\n\n      useIf = _if;\n      props = rest;\n\n      if (isValidElementType(screen)) {\n        component = screen;\n      } else if ('config' in screen) {\n        isNavigator = true;\n        component = createComponentForStaticNavigation(\n          screen,\n          `${name}Navigator`\n        );\n      }\n    } else if (isValidElementType(item)) {\n      component = item;\n    } else if ('config' in item) {\n      isNavigator = true;\n      component = createComponentForStaticNavigation(item, `${name}Navigator`);\n    }\n\n    if (component == null) {\n      throw new Error(\n        `Couldn't find a 'screen' property for the screen '${name}'. This can happen if you passed 'undefined'. You likely forgot to export your component from the file it's defined in, or mixed up default import and named import when importing.`\n      );\n    }\n\n    const element = isNavigator ? (\n      React.createElement(component, {})\n    ) : (\n      <MemoizedScreen component={component} />\n    );\n\n    return () => {\n      const shouldRender = useIf == null || useIf();\n\n      if (!shouldRender) {\n        return null;\n      }\n\n      return (\n        <Screen key={name} name={name} {...props}>\n          {() => element}\n        </Screen>\n      );\n    };\n  });\n};\n\n/**\n * Create a component that renders a navigator based on the static configuration.\n *\n * @param tree Static navigation config.\n * @param displayName Name of the component to be displayed in React DevTools.\n * @returns A component which renders the navigator.\n */\nexport function createComponentForStaticNavigation(\n  tree: StaticNavigation<any, any, any>,\n  displayName: string\n): React.ComponentType<{}> {\n  const { Navigator, Group, Screen, config } = tree;\n  const { screens, groups, ...rest } = config;\n\n  if (screens == null && groups == null) {\n    throw new Error(\n      \"Couldn't find a 'screens' or 'groups' property. Make sure to define your screens under a 'screens' property in the configuration.\"\n    );\n  }\n\n  const items: (() => JSX.Element | null)[] = [];\n\n  // Loop through the config to find screens and groups\n  // So we add the screens and groups in the same order as they are defined\n  for (const key in config) {\n    if (key === 'screens' && screens) {\n      items.push(...getItemsFromScreens(Screen, screens));\n    }\n\n    if (key === 'groups' && groups) {\n      items.push(\n        ...Object.entries(groups).map(([key, { if: useIf, ...group }]) => {\n          const groupItems = getItemsFromScreens(Screen, group.screens);\n\n          return () => {\n            // Call unconditionally since screen configs may contain `useIf` hooks\n            const children = groupItems.map((item) => item());\n\n            const shouldRender = useIf == null || useIf();\n\n            if (!shouldRender) {\n              return null;\n            }\n\n            return (\n              <Group navigationKey={key} {...group} key={key}>\n                {children}\n              </Group>\n            );\n          };\n        })\n      );\n    }\n  }\n\n  const NavigatorComponent = () => {\n    const children = items.map((item) => item());\n\n    return <Navigator {...rest}>{children}</Navigator>;\n  };\n\n  NavigatorComponent.displayName = displayName;\n\n  return NavigatorComponent;\n}\n\ntype TreeForPathConfig = {\n  config: {\n    initialRouteName?: string;\n    screens?: StaticConfigScreens<\n      ParamListBase,\n      NavigationState,\n      {},\n      EventMapBase,\n      Record<string, unknown>\n    >;\n    groups?: {\n      [key: string]: {\n        screens: StaticConfigScreens<\n          ParamListBase,\n          NavigationState,\n          {},\n          EventMapBase,\n          Record<string, unknown>\n        >;\n      };\n    };\n  };\n};\n\n/**\n * Create a path config object from a static navigation config for deep linking.\n *\n * @param tree Static navigation config.\n * @param options Additional options from `linking.config`.\n * @param auto Whether to automatically generate paths for leaf screens.\n * @returns Path config object to use in linking config.\n *\n * @example\n * ```js\n * const config = {\n *   screens: {\n *     Home: {\n *       screens: createPathConfigForStaticNavigation(HomeTabs),\n *     },\n *   },\n * };\n * ```\n */\nexport function createPathConfigForStaticNavigation(\n  tree: TreeForPathConfig,\n  options?: {\n    initialRouteName?: string;\n  },\n  auto?: boolean\n) {\n  let initialScreenConfig: PathConfig<ParamListBase> | undefined;\n\n  const createPathConfigForTree = (\n    t: TreeForPathConfig,\n    o: { initialRouteName?: string } | undefined,\n    // If a screen is a leaf node, but inside a screen with path,\n    // It should not be used for initial detection\n    skipInitialDetection: boolean\n  ) => {\n    const createPathConfigForScreens = (\n      screens: StaticConfigScreens<\n        ParamListBase,\n        NavigationState,\n        {},\n        EventMapBase,\n        Record<string, unknown>\n      >,\n      initialRouteName: string | undefined\n    ) => {\n      return Object.fromEntries(\n        Object.entries(screens)\n          // Re-order to move the initial route to the front\n          // This way we can detect the initial route correctly\n          .sort(([a], [b]) => {\n            if (a === initialRouteName) {\n              return -1;\n            }\n\n            if (b === initialRouteName) {\n              return 1;\n            }\n\n            return 0;\n          })\n          .map(([key, item]) => {\n            const screenConfig: PathConfig<ParamListBase> = {};\n\n            if ('linking' in item) {\n              if (typeof item.linking === 'string') {\n                screenConfig.path = item.linking;\n              } else {\n                Object.assign(screenConfig, item.linking);\n              }\n            }\n\n            let screens;\n\n            if ('config' in item) {\n              screens = createPathConfigForTree(\n                item,\n                undefined,\n                skipInitialDetection || screenConfig.path != null\n              );\n            } else if (\n              'screen' in item &&\n              'config' in item.screen &&\n              (item.screen.config.screens || item.screen.config.groups)\n            ) {\n              screens = createPathConfigForTree(\n                item.screen,\n                undefined,\n                skipInitialDetection || screenConfig.path != null\n              );\n            }\n\n            if (screens) {\n              screenConfig.screens = screens;\n            }\n\n            if (auto && !screenConfig.screens && !('linking' in item)) {\n              if (screenConfig.path) {\n                if (!skipInitialDetection) {\n                  // Normalize the path to remove leading and trailing slashes\n                  const path = screenConfig.path\n                    ?.split('/')\n                    .filter(Boolean)\n                    .join('/');\n\n                  // We encounter a leaf screen with empty path,\n                  // Clear the initial screen config as it's not needed anymore\n                  if (!skipInitialDetection && path === '') {\n                    initialScreenConfig = undefined;\n                  }\n                }\n              } else {\n                if (!skipInitialDetection && initialScreenConfig == null) {\n                  initialScreenConfig = screenConfig;\n                }\n\n                screenConfig.path = key\n                  .replace(/([A-Z]+)/g, '-$1')\n                  .replace(/^-/, '')\n                  .toLowerCase();\n              }\n            }\n\n            return [key, screenConfig] as const;\n          })\n          .filter(([, screen]) => Object.keys(screen).length > 0)\n      );\n    };\n\n    const screens = {};\n\n    // Loop through the config to find screens and groups\n    // So we add the screens and groups in the same order as they are defined\n    for (const key in t.config) {\n      if (key === 'screens' && t.config.screens) {\n        Object.assign(\n          screens,\n          createPathConfigForScreens(\n            t.config.screens,\n            o?.initialRouteName ?? t.config.initialRouteName\n          )\n        );\n      }\n\n      if (key === 'groups' && t.config.groups) {\n        Object.entries(t.config.groups).forEach(([, group]) => {\n          Object.assign(\n            screens,\n            createPathConfigForScreens(\n              group.screens,\n              o?.initialRouteName ?? t.config.initialRouteName\n            )\n          );\n        });\n      }\n    }\n\n    if (Object.keys(screens).length === 0) {\n      return undefined;\n    }\n\n    return screens;\n  };\n\n  const screens = createPathConfigForTree(tree, options, false);\n\n  if (auto && initialScreenConfig) {\n    initialScreenConfig.path = '';\n  }\n\n  return screens;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}